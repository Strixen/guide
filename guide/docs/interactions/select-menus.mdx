---
description: They refer to views, buttons and select menus that can be added to the messages your bot sends.
---

# Select Menus

Select Menus allow users to interact with your bot through an interactive dropdown component. This component provides selectable options for your users to choose from.
You can require users to select a minimum/maximum number of options using <DocsLink reference="disnake.ui.BaseSelect.min_values">min_values</DocsLink> and <DocsLink reference="disnake.ui.BaseSelect.max_values">max_values</DocsLink>.

Select Menus are available as the following types:

-   <DocsLink reference="disnake.ui.StringSelect">disnake.ui.StringSelect</DocsLink> Allows you to input custom string options
    for users to select from, up to 25
-   <DocsLink reference="disnake.ui.UserSelect">disnake.ui.UserSelect</DocsLink> User or Member objects as options
-   <DocsLink reference="disnake.ui.RoleSelect">disnake.ui.RoleSelect</DocsLink> Role objects as options
-   <DocsLink reference="disnake.ui.ChannelSelect">disnake.ui.ChannelSelect</DocsLink> Channel objects as options

The options for user, role, and channel select menus are populated by Discord, and currently cannot be limited to a specific subset. See [below](#other-selects) for details.

This guide will walk you through a pretty basic use-case for a `StringSelect` dropdowns using views and low-level components. If you need more examples, you can always check the examples in the [disnake repo](https://github.com/DisnakeDev/disnake/tree/master/examples).
&nbsp;  
:::note
A message can have a maximum of 5 rows of components. Select components each take a single row, therefore you cannot have more than 5 Select components per message
:::

<br />
<p align="center">
	<img src={require('./images/string-select.png').default} alt="StringSelect example" width="60%" />
</p>
<br />

### Example of `StringSelect`s

<Tabs>
<TabItem value="subclass" label="subclassing.py">

```python
import os

import disnake
from disnake.ext import commands


# Defines the StringSelect that contains animals that your users can choose from
class AnimalDropdown(disnake.ui.StringSelect):
    def __init__(self):

        # Define the options that will be presented inside the dropdown
        # you may not have more than 25 options
        # there is a value keyword that is being omitted, but that is useful if
        # you wish to display a label to the user, but handle a different value
        # here within the code, like an index number or database id
        options = [
            disnake.SelectOption(label="Dog", description="Dogs are your favorite type of animal"),
            disnake.SelectOption(label="Cat", description="Cats are your favorite type of animal"),
            disnake.SelectOption(
                label="Snake", description="Snakes are your favorite type of animal"
            ),
            disnake.SelectOption(
                label="Gerbil", description="Gerbils are your favorite type of animal"
            ),
        ]

        # We will include a placeholder that will be shown until an option has been selected
        # min and max values indicate the minimum number of options to select and the max allowed to be selected
        # in this example we will only allow one option to be selected
        # options will be where we pass the created options from above
        super().__init__(
            placeholder="Choose an animal",
            min_values=1,
            max_values=1,
            options=options,
        )

    # this callback is called each time a user has selected an option
    async def callback(self, inter: disnake.MessageInteraction):
        # Use the interaction object to respond to the interaction
        # `Self` refers to this StringSelect object, and the `values`
        # attribute contains a list of the user's selected options
        # We only want the first one
        await inter.response.send_message(f"Your favorite type of animal is: {self.values[0]}")


# Now that we have created the Select object with it's options and callback, we need to attach it to a
# view that will be displayed to the user in the command response.
# Views have a default of 180s before timing out and the bot will stop listening for those events
# you may pass any float here, or `None` if you wish to remove the timeout. Note: If None is passed
# this view will persist only until the bot is restarted.  If you wish to have persistent views,
# consider using low-level or check out the persistent view example:
# https://github.com/DisnakeDev/disnake/blob/master/examples/views/persistent.py
class DropDownView(disnake.ui.View):
    def __init__(self):
        # You would pass a new `timeout=` if you wish to alter it, but
        # we will leave it empty for this example so that it uses the default
        super().__init__()

        # now let's add the `StringSelect` object we created above to this view
        self.add_item(AnimalDropdown())


# Finally, we create a basic bot instance with a command that will utilize the created view and dropdown
bot = commands.InteractionBot()


@bot.listen()
async def on_ready():
    print(f"Logged in as {bot.user} (ID: {bot.user.id})\n------")


@bot.slash_command()
async def animals(inter: disnake.ApplicationCommandInteraction):
    """Sends a message with our dropdown containing the animals"""

    # create the view with our dropdown object
    view = DropDownView()

    # respond to the interaction with a message and our view
    await inter.response.send_message("What is your favorite type of animal?", view=view)


if __name__ == "__main__":
    bot.run(os.getenv("BOT_TOKEN"))
```

</TabItem>
<TabItem value="decorator" label="decorator.py">

```python
# instead of subclassing `disnake.ui.StringSelect`, this example shows how to use the
# `@disnake.ui.string_select` decorator directly inside the view to create the dropdown
# component.
class AnimalView(disnake.ui.View):
    def __init__(self):
        super().__init__()

        # rather than creating a large decorator, we can create the options for this component here
        # this also works if you wish to pass a list of options to this view to create options dynamically
        self.animal_callback.options = [
            disnake.SelectOption(label="Dog", description="Dogs are your favorite type of animal"),
            disnake.SelectOption(label="Cat", description="Cats are your favorite type of animal"),
            disnake.SelectOption(
                label="Snake", description="Snakes are your favorite type of animal"
            ),
            disnake.SelectOption(
                label="Gerbil", description="Gerbils are your favorite type of animal"
            ),
        ]

    @disnake.ui.string_select(
        placeholder="Choose an animal",
        min_values=1,
        max_values=1,
    )
    async def animal_callback(
        self, select: disnake.ui.StringSelect, inter: disnake.MessageInteraction
    ):
        # the main difference in this callback is that we will access the `StringSelect` directly
        # since it is passed to the callback vs the subclass example where we access it via `Self`
        await inter.response.send_message(f"You favorite type of animal is: {select.values[0]}")
```

</TabItem>
</Tabs>

### Other Selects

The three other select components available are constructed and can be used in the same manner.
The main difference is that we do not create nor pass any options to these Select objects as Discord will provide these options to the user automatically.
The selected option(s) that are available in `self.values` will be the selected object rather than a string.

-   `UserSelect.values` will return a list of <DocsLink reference="disnake.User">disnake.User</DocsLink> or <DocsLink reference="disnake.Member">disnake.Member</DocsLink>
-   `RoleSelect.values` will return a list of <DocsLink reference="disnake.Role">disnake.Role</DocsLink>
-   `ChannelSelect.values` returns a list of <DocsLink reference="disnake.abc.GuildChannel">disnake.abc.GuildChannel</DocsLink>, <DocsLink reference="disnake.Thread">disnake.Thread</DocsLink>, or <DocsLink reference="disnake.PartialMessageable">disnakeabc.PartialMessageable</DocsLink>

:::note

<DocsLink reference="disnake.ui.ChannelSelect">disnake.ui.ChannelSelect</DocsLink> has an extra keyword argument that is
not available to the other SelectMenu types.{' '}

`channel_types` will allow you to specify the types of channels made available as options, omit to add all available channels:

-   `channel_types=disnake.ChannelType.text` to display only guild text channels as options
-   `channel_types=disanke.ChannelType.voice` to display only guild voice channels as options.

See <DocsLink reference="disnake.ChannelType">disnake.ChannelType</DocsLink> to see more channel types.
:::

### Handling View Timeouts

When a view times out the bot will no longer listen for these events and your users will receive an error `This interaction failed`.

To prevent this you have a couple of options.

1.  Disable the components within the view so that they are no longer interactive.
2.  Remove the view altogether leaving only the original message.

For this example we will disable the component `on_timeout`. However, if you wish to remove the view completely you can pass `view=None` instead of `view=self` as the example below shows.

We'll continue with the original example from above, however I will only be altering the parts that matter.

```python title="viewtimeout.py"
...
...


class DropDownView(disnake.ui.View):

    message: disnake.Message  # adding to typehint the future `message` attribute

    def __init__(self):
        # this time we will set the timeout to 30.0s
        super().__init__(timeout=30.0)
        # now let's add the `StringSelect` object we created above to this view
        self.add_item(AnimalDropdown())

    # to handle this timeout, we'll need to override the default `on_timeout` method within the `View``
    async def on_timeout(self):
        # now we will edit the original command response so that it displays the disabled view
        # since `self.children` returns a list of the components attached to this `View` and we want to
        # disable the single component, we can access it with a simple [0] index
        self.children[0].disabled = True
        # now we edit the message with this updated `View`
        await self.message.edit(view=self)


...
...
# the only changes we need to make to handle the updated view is to fetch the original response after
# it has been sent.  This is required because `interaction.send` methods do not return a message object
@bot.slash_command()
async def animals(inter: disnake.ApplicationCommandInteraction):
    """Sends a message with our dropdown containing the animals"""

    # create the view with our dropdown object
    view = DropDownView()

    # respond to the interaction with a message and our view
    await inter.response.send_message("What is your favorite type of animal?", view=view)

    # this will add a new `message` attribute to the `DropDownView` that will be edited
    # once the view has timed out
    view.message = await inter.original_response()


...
```

### Views vs. low-level components

As an alternative to using `View`s, it is possible to use Select Menus as low-level components.
These components do not need to be sent as part of a View and can be sent as is.

Note that any component being sent in this manner must have a `custom_id` explicitly set. Component interactions are sent to all listeners,
which means the `custom_id` should be unique for each component to be able to identify the component in your code.

The main advantage of this is that listeners, by nature, are persistent and will remain fully functional over bot reloads. Listeners are stored in the bot
strictly once, and are shared by all components. Because of this, the memory footprint will generally be smaller
than that of an equivalent view.

The example below will be similar to the above examples, however will be executed as a low level component instead.

```python title="low_level_dropdown.py"
@bot.slash_command()
async def animals(inter: disnake.ApplicationCommandInteraction):
    """Sends a message with our dropdown containing the animals"""

    await inter.response.send_message(
        "What is your favorite type of animal?",
        components=[
            disnake.ui.StringSelect(
                custom_id="fav_animal",
                options=["Dog", "Cat", "Snake", "Gerbil"],
            )
        ],
    )


# Now we create the listener that will handle the users's selection, similar to the callback we used above
@bot.listen("on_dropdown")
async def fav_animal_listener(inter: disnake.MessageInteraction):
    # first we should check if the interaction is for the `fav_animal` dropdown we created
    # and ignore if it isn't.
    if inter.component.custom_id != "fav_animal":
        return

    # now we can respond with the user's favorite animal
    await inter.response.send_message(f"Your favorite type of animal is: {inter.values[0]}")
```

:::note
These component listeners can be used inside cogs as well. Simply replace `@bot.listen()` with `@commands.Cog.listener()` and
be sure to pass `self` as the first argument of the listener function
:::
